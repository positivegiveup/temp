data segment

    ;-----------------------------------------
    ; ARRAY OF 50 INTEGERS.
    arr dw 5, 1, 8, 9, 10, 17, 18, 20, 24, 30
    ;-----------------------------------------

    i   dw  ? 
    j   dw  ?
    p   dw  0                           ; START OF THE ARRAY, EQUALS TO 0.
    r   dw  9                           ; END OF THE ARRAY, EQUALS TO A.LENGTH - 1.
    q   dw  ?
    x   dw  ?

ends

stack segment

    stk db  100  dup(0)
    top equ 100

ends

code segment

    assume cs: code, ds: data, ss:stack

    start:

        ; INITIALIZE DATA SEGMENT.
        mov  ax, @data
        mov  ds, ax
        mov  ax, stack
        mov  ss, ax
        mov  sp, top

        ; CALL QUICKSORT(A, 0, A.LENGTH-1).
        call quicksort

        ; PRINT SORTED ARRAY.
        call print_array

        ; WAIT FOR ANY KEY.
        mov  ah, 7
        int  21h

        ; FINISH PROGRAM.
        mov  ax, 4c00h
        int  21h

        ;-----------------------------------------
        ; PRINT ARRAY PROCEDURE
        ; Loops through the array and prints each element
        ;-----------------------------------------
        print_array proc
            mov si, offset arr         ; Set SI to the start of the array
            mov cx, 10                 ; Number of elements in the array
        print_loop:
            mov ax, [si]               ; Load current element into AX
            call print_number          ; Call procedure to print AX
            add si, 2                  ; Move to the next element (2 bytes per element)
            loop print_loop            ; Repeat for all elements
            ret
        print_array endp

        ;-----------------------------------------
        ; PRINT NUMBER PROCEDURE
        ; Converts AX to ASCII and prints it
        ;-----------------------------------------
        print_number proc
            push ax                    ; Save AX
            push bx                    ; Save BX
            push cx                    ; Save CX
            push dx                    ; Save DX

            mov cx, 0                  ; Initialize digit counter
        convert_loop:
            xor dx, dx                 ; Clear DX
            mov bx, 10                 ; Divisor for decimal conversion
            div bx                     ; AX / 10, remainder in DX, quotient in AX
            push dx                    ; Save remainder (digit)
            inc cx                     ; Increment digit counter
            test ax, ax                ; Check if quotient is 0
            jnz convert_loop           ; Repeat until AX is 0

        print_digits:
            pop dx                     ; Get next digit
            add dl, '0'                ; Convert to ASCII
            mov ah, 2                  ; DOS interrupt for character output
            int 21h                    ; Print character
            loop print_digits          ; Print all digits

            ; Print space after number
            mov ah, 2
            mov dl, ' '
            int 21h

            pop dx                     ; Restore DX
            pop cx                     ; Restore CX
            pop bx                     ; Restore BX
            pop ax                     ; Restore AX
            ret
        print_number endp

        ;-----------------------------------------
        ; QUICKSORT PROCEDURE
        ;-----------------------------------------
        quicksort proc
            ; COMPARE P WITH R.
            mov  ax, p 
            cmp  ax, r                  ; COMPARE P WITH R
            jge  bigger1                ; IF P >= R, SORT IS DONE.

            ; CALL PARTITION(A, P, R).
            call partition

            ; GET Q = PARTITION(A, P, R).
            mov  q, ax

            ; PUSH Q+1, R INTO STACK FOR LATER USAGE.
            inc  ax
            push ax
            push r

            ; CALL QUICKSORT(A, P, Q-1).
            mov  ax, q
            mov  r, ax
            dec  r
            call quicksort

            ; CALL QUICKSORT(A, Q+1, R).
            pop  r
            pop  p 
            call quicksort 

            ; WHEN SORT IS DONE.
            bigger1:
                ret
        quicksort endp

        ;-----------------------------------------
        ; PARTITION PROCEDURE
        ;-----------------------------------------
        partition proc
            ; GET X = ARR[ R ].
            mov  si, offset arr
            mov  ax, r
            shl  ax, 1                  ; R * 2, BECAUSE EVERY COUNTER IS 2 BYTES.
            add  si, ax
            mov  ax, [ si ]       
            mov  x,  ax                 ; X = ARR[ R ].

            ; GET I = P - 1.
            mov  ax, p
            mov  i,  ax
            dec  i

            ; INITIALISE J WITH P.
            mov  ax, p
            mov  j,  ax

            ; LOOP J FROM P TO R-1.
            for_j:

                ; GET ARR[ J ].
                mov  si, offset arr
                mov  ax, j
                shl  ax, 1              ; J * 2, BECAUSE EVERY COUNTER IS 2 BYTES.
                add  si, ax
                mov  ax, [ si ]         ; AX = ARR[ J ]

                ; COMPARE A[ J ] WITH X.
                cmp  ax, x
                jg   bigger             ; IF A[ J ] > X, NO SWAP

                ; GET I = I + 1.
                inc  i
                
                ; GET ARR[ I ].
                mov  di, offset arr
                mov  cx, i
                shl  cx, 1              ; I * 2, BECAUSE EVERY COUNTER IS 2 BYTES.
                add  di, cx
                mov  cx, [ di ]         ; CX = ARR[ I ].

                ; EXCHANGE ARR[ I ] WITH ARR[ J ].
                mov  [ di ], ax
                mov  [ si ], cx
            
                ; GET NEXT J.
                bigger:

                    inc  j              ; J = J + 1.
                    mov  ax, r
                    cmp  j,  ax         ; COMPARE J WITH R.
                    jl   for_j          ; IF J < R, CONTINUE LOOP.

            ; GET ARR[ i+1 ].
            inc  i
            mov  si, offset arr
            mov  ax, i
            shl  ax, 1                  ; (I+1) * 2, BECAUSE EVERY COUNTER IS 2 BYTES.
            add  si, ax
            mov  ax, [ si ]             ; AX = ARR[ I+1 ].

            ; GET ARR[ R ].
            mov  di, offset arr
            mov  cx, r
            shl  cx, 1                  ; R * 2, BECAUSE EVERY COUNTER IS 2 BYTES.
            add  di, cx
            mov  cx, [ di ]             ; CX = ARR[ R ].

            ; EXCHANGE ARR[ I+1 ] WITH ARR[ R ].
            mov  [ di ], ax
            mov  [ si ], cx  

            ; RETURN I+1.
            mov  ax, i
            ret
        partition endp

ends

    end start
